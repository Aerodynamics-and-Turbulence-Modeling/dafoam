'''
Read the Jacobian mat connectivity information and plot the connected states for a given rowI and colI
NOTE: First run MatGetValues to generate the connectivity information and save to the case root folder and 
rename it as con.info. Keep only the data and delete any headers.
Then open paraview-5.4.1 and load this script through tools-Python Shell-Run Script
'''
#### import the simple module from the paraview
from paraview.simple import *
import subprocess,os
#### disable automatic camera reset on 'Show'
paraview.simple._DisableFirstRenderCameraReset()

rowindx=1 # this needs to be consistent with the rowindx value in MatGetRow
nProcs=1  # this will be used when reading AdjointIndexing.txt
conInfo='con.info' # con info file generated by MatGetRow
rootPath='./'
conMatMode='state' # either state or xv

os.chdir(rootPath)

# create a new 'OpenFOAMReader'
curvedCubefoam = OpenFOAMReader(FileName='./paraview.foam')
# get animation scene
animationScene1 = GetAnimationScene()
# update animation scene based on data timesteps
animationScene1.UpdateAnimationUsingDataTimeSteps()
# get active source.
openFOAMReader1 = GetActiveSource()
# Properties modified on openFOAMReader1
openFOAMReader1.CaseType = 'Reconstructed Case'
# get active view
renderView1 = GetActiveViewOrCreate('RenderView')
# uncomment following to set a specific view size
# renderView1.ViewSize = [1539, 875]
# show data in view
curvedCubefoamDisplay = Show(curvedCubefoam, renderView1)
# reset view to fit data
renderView1.ResetCamera()
# Properties modified on renderView1
#renderView1.Background = [1.0, 1.0, 1.0]
# show color bar/color legend
#curvedCubefoamDisplay.SetScalarBarVisibility(renderView1, True)
# get color transfer function/color map for 'p'
#pLUT = GetColorTransferFunction('p')
# get opacity transfer function/opacity map for 'p'
#pPWF = GetOpacityTransferFunction('p')
# change representation type
curvedCubefoamDisplay.SetRepresentationType('Surface With Edges')
# turn off scalar coloring
#ColorBy(curvedCubefoamDisplay, None)
# Properties modified on curvedCubefoamDisplay
curvedCubefoamDisplay.Opacity = 0.5

# now load the connectivity points
# get the non-zero col index for a given row
colConn=[]
colConnLv=[]
fCon=open(conInfo,'r')
for line in fCon:
    line = line.strip()  # get rid of \n
    columns = line.split() # split all the columns in one line
    colConn.append(columns[0])
    colConnLv.append(float(columns[1]))
colConn = map(int, colConn)
colConnLv = map(int, colConnLv)

# read Rx Ry Rz
for myRank in range(nProcs):
    fState = open('AdjointIndexing_%d_of_%d.txt' % (myRank, nProcs), 'r')
    for line in fState:
        line = line.strip()  # get rid of \n
        columns = line.split()  # split all the columns in one line
        if (rowindx == int(columns[5])):
            Rx = columns[7]
            Ry = columns[9]
            Rz = columns[11]
            RName = columns[5]
    fState.close()
print(RName,Rx, Ry, Rz)

if conMatMode=='state' or conMatMode=='bnd':
    # read cell state coords
    Sx=[]
    Sy=[]
    Sz=[]
    SS=[]
    Si=[]
    Sl=[]
    for myRank in range(nProcs):
        fState=open('AdjointIndexing_%d_of_%d.txt'%(myRank,nProcs),'r')
        for line in fState:
            line = line.strip()  # get rid of \n
            columns = line.split() # split all the columns in one line
            for i in range(len(colConn)):
                if ( colConn[i] == int(columns[5]) ):
                    Sx.append(float(columns[7]))
                    Sy.append(float(columns[9]))
                    Sz.append(float(columns[11]))
                    SS.append(columns[3])
                    Si.append(int(columns[5]))
                    Sl.append(colConnLv[i])
        fState.close()
elif conMatMode=='point':
    # read point coords
    Px=[]
    Py=[]
    Pz=[]
    Pi=[]
    PCoord=[]
    for myRank in range(nProcs):
        fPoint = open('PointIndexing_%d_of_%d.txt' % (myRank, nProcs), 'r')
        for line in fPoint:
            line = line.strip()  # get rid of \n
            columns = line.split()  # split all the columns in one line
            for i in range(len(colConn)):
                if (colConn[i] == int(columns[5])):
                    Px.append(float(columns[7]))
                    Py.append(float(columns[9]))
                    Pz.append(float(columns[11]))
                    Pi.append(int(columns[5]))
                    PCoord.append(int(columns[3]))
        fPoint.close()


# create a new 'Point Source'

pointSource1 = PointSource()
pointSource1.Center = [float(Rx), float(Ry), float(Rz)]
pointSource1Display = Show(pointSource1, renderView1)
pointSource1Display.PointSize = 40.0
pointSource1Display.DiffuseColor = [0.0, 0.0, 0.0]
activeCell = GetActiveSource()
RenameSource('%sRes'%RName,activeCell)
     
if conMatMode=='state':
    pointDict={}
    pointDictDisplay={}
    for i in range(len(Sx)):
        
        if ("U1" in SS[i]) or ("U2" in SS[i]):
            continue 
        
        if ("D1" in SS[i]) or ("D2" in SS[i]):
            continue 
        
        varName=SS[i]+'_'
            
        pointDict['%s%d'%(varName,Si[i])] = PointSource()
        pointDict['%s%d'%(varName,Si[i])].Center = [Sx[i], Sy[i], Sz[i]]
        pointDictDisplay['%s%d'%(varName,Si[i])] = Show(pointDict['%s%d'%(varName,Si[i])], renderView1)
        
        if "U" in SS[i] or "D" in SS[i]:
            pointDictDisplay['%s%d'%(varName,Si[i])].PointSize = 40.0
            pointDictDisplay['%s%d'%(varName,Si[i])].DiffuseColor = [1.0, 0.0, 0.0] # red
            pointDictDisplay['%s%d'%(varName,Si[i])].Opacity = 0.3
        if ("p" in SS[i]) or ("p_rgh" in SS[i]):
            pointDictDisplay['%s%d'%(varName,Si[i])].PointSize = 30.0
            pointDictDisplay['%s%d'%(varName,Si[i])].DiffuseColor = [0.0, 1.0, 0.0] # green
            pointDictDisplay['%s%d'%(varName,Si[i])].Opacity = 0.4
        if ("T" in SS[i]) or ("e" in SS[i]):
            pointDictDisplay['%s%d'%(varName,Si[i])].PointSize = 20.0
            pointDictDisplay['%s%d'%(varName,Si[i])].DiffuseColor = [1.0, 1.0, 1.0] # white
            pointDictDisplay['%s%d'%(varName,Si[i])].Opacity = 0.4
        if "nuTilda" in SS[i]:
            pointDictDisplay['%s%d'%(varName,Si[i])].PointSize = 10.0
            pointDictDisplay['%s%d'%(varName,Si[i])].DiffuseColor = [0.0, 0.0, 1.0] # blue
            pointDictDisplay['%s%d'%(varName,Si[i])].Opacity = 0.5
        if "k" in SS[i]:
            pointDictDisplay['%s%d'%(varName,Si[i])].PointSize = 10.0
            pointDictDisplay['%s%d'%(varName,Si[i])].DiffuseColor = [0.0, 0.0, 1.0] # blue
            pointDictDisplay['%s%d'%(varName,Si[i])].Opacity = 0.5
        if "omega" in SS[i]:
            pointDictDisplay['%s%d'%(varName,Si[i])].PointSize = 10.0
            pointDictDisplay['%s%d'%(varName,Si[i])].DiffuseColor = [0.0, 1.0, 1.0] # 
            pointDictDisplay['%s%d'%(varName,Si[i])].Opacity = 0.5
        if "phi" in SS[i]:
            pointDictDisplay['%s%d'%(varName,Si[i])].PointSize = 10.0
            pointDictDisplay['%s%d'%(varName,Si[i])].DiffuseColor = [1.0, 1.0, 0.0] # yellow
                        
        activePoint = GetActiveSource()
        RenameSource('%s%d'%(varName,Si[i]),activePoint)
elif conMatMode=='bnd':
    pointDict={}
    pointDictDisplay={}
    for i in range(len(Sx)):
        
        if (not "U1" in SS[i]) and (not "phi" in SS[i]):
            continue

        varName=SS[i]+'_'
            
        pointDict['%s%d'%(varName,Sl[i])] = PointSource()
        pointDict['%s%d'%(varName,Sl[i])].Center = [Sx[i], Sy[i], Sz[i]]
        pointDictDisplay['%s%d'%(varName,Sl[i])] = Show(pointDict['%s%d'%(varName,Sl[i])], renderView1)
        
        if Sl[i]==1:
            pointDictDisplay['%s%d'%(varName,Sl[i])].PointSize = 40.0
            pointDictDisplay['%s%d'%(varName,Sl[i])].DiffuseColor = [1.0, 0.0, 0.0] # red
        elif Sl[i]==2:
            pointDictDisplay['%s%d'%(varName,Sl[i])].PointSize = 30.0
            pointDictDisplay['%s%d'%(varName,Sl[i])].DiffuseColor = [1.0, 1.0, 1.0] # white
        elif Sl[i]==3:    
            pointDictDisplay['%s%d'%(varName,Sl[i])].PointSize = 20.0
            pointDictDisplay['%s%d'%(varName,Sl[i])].DiffuseColor = [0.0, 1.0, 1.0] # 
        elif Sl[i]==10:
            pointDictDisplay['%s%d'%(varName,Sl[i])].PointSize = 10.0
            pointDictDisplay['%s%d'%(varName,Sl[i])].DiffuseColor = [1.0, 1.0, 0.0] # yellow
                        
        activePoint = GetActiveSource()
        RenameSource('%s%d'%(varName,Sl[i]),activePoint)

elif conMatMode=='point':
    pointDict={}
    pointDictDisplay={}
    for i in range(len(Px)):
        
        if (PCoord[i]==1) or (PCoord[i]==2):
            continue 
        
        varName='point'
            
        pointDict['%s%d'%(varName,Pi[i])] = PointSource()
        pointDict['%s%d'%(varName,Pi[i])].Center = [Px[i], Py[i], Pz[i]]
        pointDictDisplay['%s%d'%(varName,Pi[i])] = Show(pointDict['%s%d'%(varName,Pi[i])], renderView1)
        
        pointDictDisplay['%s%d'%(varName,Pi[i])].PointSize = 20.0
        pointDictDisplay['%s%d'%(varName,Pi[i])].DiffuseColor = [0.0, 0.0, 1.0] # blue
        pointDictDisplay['%s%d'%(varName,Pi[i])].Opacity = 0.5
                        
        activePoint = GetActiveSource()
        RenameSource('%s%d'%(varName,Pi[i]),activePoint)
    
    
    
    

